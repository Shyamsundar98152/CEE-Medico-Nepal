<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Quiz — CEE Medico Nepal</title>
<meta name="description" content="Daily scheduled chapter quiz — auto loads chapter by time and saves participant results locally" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  /* Base Styles */
  :root{
    --blue: #003366;
    --accent: #0056b3;
    --card: #ffffff;
    --muted: #6b7280;
    --green: #16a34a;
    --red: #ef4444;
    --light-green: #d1fae5;
    --light-red: #ffe4e6;
    --border-color: #e6eef8;
  }
  *{box-sizing:border-box}
  body{
    font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin:0;
    background:#f3f6fb;
    color:#0f172a;
    line-height: 1.6;
  }
  header, footer{
    background:var(--blue);
    color:#fff;
    padding:14px 18px;
    text-align:center;
  }
  main{
    max-width:980px;
    margin:20px auto;
    padding:18px;
  }
  .card{
    background:var(--card);
    border-radius:12px;
    padding:18px;
    box-shadow:0 6px 18px rgba(2,6,23,0.06);
    margin-bottom:16px;
  }
  h1{margin:0;font-size:1.6rem}
  h2{color:var(--blue); margin:6px 0 14px; font-size:1.4rem}
  h3{margin-top:0; font-size:1.2rem; color:var(--blue);}

  /* Layout and Controls */
  .row{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap: wrap; /* Allows wrapping on smaller screens */
  }
  .col{flex:1; min-width: 150px;} /* Ensure column has minimum width */
  #chapter-title{font-weight:600; font-size:1.1rem;}
  .meta{color:var(--muted); font-size:0.95rem}
  .controls{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-top:10px;
    justify-content: center; /* Center buttons horizontally */
  }
  input[type="text"], button, select {
    padding:10px 15px;
    border-radius:8px;
    border:1px solid var(--border-color);
    font-size:1rem;
    width: 100%; /* Full width for inputs */
    max-width: 100%;
  }
  button{
    background:var(--accent);
    color:white;
    border:0;
    cursor:pointer;
    transition: background-color 0.2s ease;
  }
  button:hover:not([disabled]){
    background: #004085;
  }
  button[disabled]{
    opacity:.6;
    cursor:not-allowed;
  }
  .option-btn{
    display:block;
    width:100%;
    text-align:left;
    padding:12px;
    border-radius:10px;
    border:1px solid var(--border-color);
    margin:8px 0;
    background:#f8fcff;
    cursor:pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
  }
  .option-btn:hover:not([data-answered="true"]){ /* Prevent hover effect after answer */
    background:#e8f6ff;
  }
  #options-container{margin-top:8px;}
  #quiz-results{
    display:flex;
    flex-direction:column;
    gap:8px;
    align-items:center;
    text-align: center;
  }
  .participant{
    display:flex;
    justify-content:space-between;
    padding:8px 10px;
    border-radius:6px;
    background: #fdfefe;
    border: 1px solid var(--border-color);
    width: 100%;
    margin-bottom: 5px;
  }
  .small{font-size:.9rem;color:var(--muted)}
  .center{text-align:center}
  .hidden{display:none !important;} /* Ensures hidden elements are truly hidden */

  /* Specific Button Styles */
  #submit-btn{background:var(--green);}
  #submit-btn:hover:not([disabled]){background:#137f3a;}
  #restart-btn{background:var(--red);}
  #restart-btn:hover:not([disabled]){background:#b91c1c;}
  #save-result-btn {background: var(--blue);}
  #save-result-btn:hover:not([disabled]) {background: #002244;}

  /* Quiz Area Specifics */
  #countdown {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--blue);
    margin-bottom: 10px;
  }
  #explanation {
    margin-top: 15px;
    font-style: italic;
    color: #333;
    padding: 10px;
    background: #eaf1f8;
    border-radius: 8px;
    border: 1px solid #d0e0f0;
  }

  /* Responsive Adjustments */
  @media (max-width:640px){
    main{padding:10px;}
    .row{flex-direction:column;align-items:stretch;}
    .col{min-width: unset;}
    input[type="text"], button{width: 100%;}
    .controls button{width: calc(50% - 4px);} /* Two buttons per row on small screens */
    .controls button:last-child:nth-child(odd) { width: 100%; } /* Last button full width if odd count */
    h1{font-size:1.3rem;}
    h2{font-size:1.2rem;}
    .option-btn{padding:10px;}
  }

  /* Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: var(--card);
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    max-width: 400px;
    width: 90%;
    text-align: center;
    position: relative; /* For the close button */
  }
  .modal-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 1.5rem;
    cursor: pointer;
    background: none;
    border: none;
    color: var(--muted);
    padding: 0;
  }
  .modal-close-btn:hover {
    color: var(--accent);
  }
  .modal-content button {
    margin-top: 20px;
    padding: 10px 20px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    width: auto; /* Reset width for modal buttons */
  }
</style>
</head>
<body>
<header>
  <h1>CEE Medico — Daily Chapter Quiz</h1>
  <div class="small">Auto-load by schedule (Local time) • Results stored locally only</div>
</header>

<main>
  <div class="card">
    <div id="status">
      <div id="chapter-title">Loading schedule...</div>
      <div class="meta" id="schedule-info">Checking local time…</div>
    </div>
    <div style="margin-top:12px" id="controls-area">
      <div class="row">
        <div class="col">
          <input id="participant-name" type="text" placeholder="Your name (optional for local result)" />
        </div>
        <div>
          <button id="join-button" disabled>Wait for quiz</button>
        </div>
      </div>
      <div class="small" style="margin-top:8px">Participant name is for your local reference only. Results are not saved externally.</div>
    </div>
  </div>

  <!-- Display Schedule -->
  <div class="card">
    <h3 style="margin-top:0">Upcoming Chapters</h3>
    <div id="schedule-display" class="leaderboard">
      No schedule loaded.
    </div>
  </div>

  <div id="quiz-area" class="card hidden">
    <div id="countdown" class="small center"></div>
    <div id="question-num" class="small"></div>
    <h2 id="question-text"></h2>
    <div id="options-container"></div>
    <div id="explanation" class="small center"></div>

    <div class="controls" style="margin-top:12px">
      <button id="prev-btn">Previous</button>
      <button id="skip-btn">Skip</button>
      <button id="next-btn">Next</button>
      <button id="submit-btn">Submit Quiz</button>
    </div>
  </div>

  <div id="results-area" class="card hidden">
    <div id="quiz-results">
      <h2 class="center">Quiz Result</h2>
      <div class="center">
        <div>Total Questions: <span id="res-total">0</span></div>
        <div>Correct Answers: <span id="res-correct">0</span></div>
        <div>Wrong Answers: <span id="res-wrong">0</span></div>
        <div>Skipped Questions: <span id="res-skipped">0</span></div>
      </div>
      <div style="margin-top:12px" class="center">
        <button id="save-result-btn">Save Result (Local)</button>
        <button id="restart-btn">Restart Quiz</button>
      </div>

      <h3 style="margin-top:20px; margin-bottom: 10px;">Your Local History</h3>
      <div id="local-history-display" style="width:100%;">
        <div class="small center">No previous results saved locally.</div>
      </div>
    </div>
  </div>

  <div class="card small" id="notes">
    <strong>Notes:</strong> The schedule is embedded within this file. The site uses your **local device's time** for scheduling. Quiz results are **only stored locally** within your browser and are not shared or saved to any external database.
  </div>
</main>

<footer>
  <div class="small">© 2025 CEE Medico Nepal</div>
</footer>

<!-- Modal for messages -->
<div id="modal-message-overlay" class="modal-overlay hidden">
  <div class="modal-content">
    <button class="modal-close-btn" id="modal-message-close">&times;</button>
    <p id="modal-message-text"></p>
    <button id="modal-message-ok">OK</button>
  </div>
</div>

<script>
/* =========================
   EMBEDDED CHAPTERS.TXT CONTENT
   ========================= */
const EMBEDDED_CHAPTERS_TXT = `
2025-08-09 20:48 | Physics - Mechanics
2025-08-11 21:00 | Chemistry - Atomic Structure
2025-08-11 22:00 | Zoology - Cell Structure & Function

2025-08-12 19:00 | Physics - Laws of Motion
2025-08-12 21:00 | Chemistry - Chemical Bonding
2025-08-12 22:00 | Botany - Cell Structure & Function

2025-08-13 19:00 | Physics - Work, Energy & Power
2025-08-13 21:00 | Chemistry - States of Matter
2025-08-13 22:00 | Zoology - Biomolecules

2025-08-14 19:00 | Physics - Thermodynamics
2025-08-14 21:00 | Chemistry - Chemical Kinetics
2025-08-14 22:00 | Botany - Plant Kingdom

2025-08-15 19:00 | Physics - Waves & Sound
2025-08-15 21:00 | Chemistry - Surface Chemistry
2025-08-15 22:00 | Zoology - Human Physiology - Digestion

2025-08-16 19:00 | Physics - Electrostatics
2025-08-16 21:00 | Chemistry - Electrochemistry
2025-08-16 22:00 | Botany - Plant Physiology

2025-08-17 19:00 | Physics - Current Electricity
2025-08-17 21:00 | Chemistry - Coordination Compounds
2025-08-17 22:00 | Zoology - Human Physiology - Circulatory System

2025-08-18 19:00 | Physics - Magnetism
2025-08-18 21:00 | Chemistry - Organic Chemistry - Hydrocarbons
2025-08-18 22:00 | Botany - Genetics

2025-08-19 19:00 | Physics - Modern Physics
2025-08-19 21:00 | Chemistry - Nuclear Chemistry
2025-08-19 22:00 | Zoology - Human Physiology - Nervous System

2025-08-20 19:00 | Physics - Optics
2025-08-20 21:00 | Chemistry - Environmental Chemistry
2025-08-20 22:00 | Botany - Evolution and Ecology

`;


/* =========================
   CONFIG
   ========================= */
const GEMINI_API_KEY = "AIzaSyD8HWf_Zp0WsS14RJ2vxTUxjXvPCyiNpDo"; // Canvas environment will provide it at runtime.
const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
const LOCAL_STORAGE_KEY_RESULTS = "ceeMedicoQuizResults";
const LOCAL_STORAGE_KEY_NAME = "ceeMedicoParticipantName";

/* =========================
   GLOBAL STATE
   ========================= */
let schedule = [];             // array of {time:Date, chapter:string}
let currentChapter = null;     // {time, chapter}
let quizData = [];             // array of questions from Gemini
let currentQuestionIndex = 0;
let countdownTimer = null;
let questionTimer = null;
let participantName = "";

/* =========================
   Helpers
   ========================= */
function el(id){ return document.getElementById(id); }
function show(q){ q.classList.remove('hidden'); q.style.display = ''; }
function hide(q){ q.classList.add('hidden'); q.style.display = 'none'; }

function showMessage(msg, callback = null) {
    el('modal-message-text').innerText = msg;
    show(el('modal-message-overlay'));
    el('modal-message-ok').onclick = () => {
        hide(el('modal-message-overlay'));
        if (callback) callback();
    };
    el('modal-message-close').onclick = () => {
        hide(el('modal-message-overlay'));
        if (callback) callback();
    };
}

/* =========================
   Local Storage Management
   ========================= */
function saveParticipantNameLocally(name) {
    localStorage.setItem(LOCAL_STORAGE_KEY_NAME, name);
}

function getParticipantNameLocally() {
    return localStorage.getItem(LOCAL_STORAGE_KEY_NAME) || "";
}

function saveQuizResultLocally(result) {
    const results = getQuizResultsLocally();
    results.push(result);
    localStorage.setItem(LOCAL_STORAGE_KEY_RESULTS, JSON.stringify(results));
    renderLocalHistory(); // Re-render history after saving
}

function getQuizResultsLocally() {
    try {
        return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_RESULTS) || "[]");
    } catch (e) {
        console.error("Error parsing local results:", e);
        return [];
    }
}

function renderLocalHistory() {
    const historyDisplayEl = el('local-history-display');
    const results = getQuizResultsLocally();

    if (results.length === 0) {
        historyDisplayEl.innerHTML = '<div class="small center">No previous results saved locally.</div>';
        return;
    }

    // Sort by date descending
    results.sort((a, b) => new Date(b.date) - new Date(a.date));

    historyDisplayEl.innerHTML = results.map(r => {
        const dateStr = new Date(r.date).toLocaleString('en-NP', {
            year: 'numeric', month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit', hour12: true
        });
        return `
            <div class="participant">
                <div><strong>${escapeHtml(r.name || 'Anonymous')}</strong> on ${dateStr}</div>
                <div>${r.correct} / ${r.total} Correct (${r.skipped} skipped)</div>
            </div>
        `;
    }).join('');
}


/* =========================
   Load schedule from embedded text
   ========================= */
async function loadSchedule(){
  try{
    const txt = EMBEDDED_CHAPTERS_TXT;
    if(!txt) throw new Error("Embedded schedule content is empty.");

    schedule = txt.trim().split('\n').map(l=>{
      const parts = l.split('|');
      const dt = parts[0].trim(); // "YYYY-MM-DD HH:MM"
      const ch = (parts[1]||"").trim();
      const m = dt.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})/);
      if(!m) return null;
      const [_,y,mo,d,h,mi] = m;
      // Note: Month is 0-indexed in Date constructor
      const dateObj = new Date(Number(y), Number(mo)-1, Number(d), Number(h), Number(mi), 0, 0);
      return {time: dateObj, chapter: ch};
    }).filter(Boolean).sort((a,b)=>a.time - b.time);

    renderSchedule(); // Display schedule after loading

  }catch(e){
    console.error("Error loading schedule:", e);
    schedule = [];
    el('chapter-title').innerText = `Error loading schedule: ${e.message}.`;
    el('schedule-display').innerHTML = `<div class="small">Error loading schedule: ${e.message}</div>`;
  }
}

/* =========================
   Render Schedule on the page
   ========================= */
function renderSchedule() {
  const scheduleDisplayEl = el('schedule-display');
  if (schedule.length === 0) {
    scheduleDisplayEl.innerHTML = '<div class="small">No upcoming chapters scheduled.</div>';
    return;
  }
  const now = new Date();
  const upcomingSchedule = schedule.filter(entry => entry.time >= now);

  if (upcomingSchedule.length === 0) {
    scheduleDisplayEl.innerHTML = '<div class="small">All scheduled quizzes have passed.</div>';
    return;
  }

  scheduleDisplayEl.innerHTML = upcomingSchedule.map(entry => {
    const timeStr = entry.time.toLocaleString('en-NP', {
      year: 'numeric', month: 'short', day: 'numeric',
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    return `<div class="participant"><div>${escapeHtml(entry.chapter)}</div><div>${timeStr}</div></div>`;
  }).join('');
}

/* =========================
   Get accurate Nepal time (local device time)
   ========================= */
async function getAccurateTime(){
  // Using local device time as per request
  return new Date();
}

/* =========================
   Find latest chapter <= now
   ========================= */
function pickCurrentChapter(now){
  let picked = null;
  for(const entry of schedule){
    if(now >= entry.time) picked = entry;
  }
  return picked;
}

/* =========================
   Exponential Backoff for API calls
   ========================= */
async function fetchWithExponentialBackoff(url, options, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);
            if (response.status === 429 || !response.ok) { // Too Many Requests or other non-OK status
                if (i < retries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    continue;
                }
            }
            return response;
        } catch (error) {
            if (i < retries - 1) {
                await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                continue;
            }
            throw error; // Re-throw if all retries fail
        }
    }
}

/* =========================
   Gemini generate (50 MCQs)
   ========================= */
async function generateMCQs(chapter){
  el('chapter-title').innerText = `Generating questions for "${chapter}" — please wait... (This may take a moment)`;
  const prompt = `
Generate 30 NEET / CEE-level multiple choice questions in JSON (array) on the chapter "${chapter}" based on NEB / MEC syllabus Nepal. Each question must have exactly 4 options. Ensure the correct option is clearly indicated by its index (0-3).

Use exactly this JSON schema:
[
  {
    "question": "text of the question",
    "options": ["Option A","Option B","Option C","Option D"],
    "correct": 0, // index of the correct option (0 for A, 1 for B, etc.)
    "explanation": "short explanation for the correct answer"
  }
]
Return JSON array only. Do not include any other text or markdown outside the JSON.
`.trim();

  const payload = {
    contents: [{ role: "user", parts: [{ text: prompt }] }],
    generationConfig: { responseMimeType: "application/json" }
  };

  try{
    const r = await fetchWithExponentialBackoff(GEMINI_URL, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    });

    if(!r.ok){
      const errText = await r.text();
      throw new Error(`Gemini API failed: ${r.status} - ${errText}`);
    }
    const json = await r.json();
    const raw = json?.candidates?.[0]?.content?.parts?.[0]?.text || '';
    const parsed = JSON.parse(raw);

    // Basic validation of the parsed quiz data
    if (!Array.isArray(parsed) || parsed.length === 0) {
        throw new Error("Gemini returned an empty or invalid quiz data structure.");
    }
    parsed.forEach((q, idx) => {
        if (!q.question || !Array.isArray(q.options) || q.options.length !== 4 || typeof q.correct !== 'number' || q.correct < 0 || q.correct > 3 || !q.explanation) {
            console.warn(`Question ${idx} failed schema validation:`, q);
            // Optionally, remove malformed questions or throw a harder error
        }
    });

    return parsed;
  }catch(e){
    console.error("Gemini error", e);
    throw e;
  }
}

/* =========================
   Quiz UI functions
   ========================= */
function renderQuestion(){
  if(!quizData.length) return;
  const q = quizData[currentQuestionIndex];
  el('question-num').innerText = `Question ${currentQuestionIndex + 1} / ${quizData.length}`;
  el('question-text').innerText = q.question || '';
  el('explanation').innerText = ''; // Clear previous explanation
  const cont = el('options-container'); cont.innerHTML = ''; // Clear previous options

  (q.options||[]).forEach((opt,i)=>{
    const btn = document.createElement('button');
    btn.className = 'option-btn';
    btn.innerText = opt;
    btn.dataset.index = i; // Store index for easy lookup
    btn.dataset.answered = q.answered ? 'true' : 'false'; // Mark if already answered

    if (q.answered) {
        // If question was answered, apply styles
        if (i === q.userAnswer) {
            btn.style.background = i === q.correct ? var_light_green : var_light_red;
            btn.style.border = i === q.correct ? `1px solid ${var_green}` : `1px solid ${var_red}`;
        } else if (i === q.correct) {
            // Highlight correct answer if user answered incorrectly
            btn.style.background = var_light_green;
            btn.style.border = `1px solid ${var_green}`;
        }
        el('explanation').innerText = (q.userAnswer === q.correct ? '✅ Correct. ' : '❌ Incorrect. Correct answer: ' + (q.options && q.options[q.correct] ? q.options[q.correct] : '')) + (q.explanation ? ' — ' + q.explanation : '');
    }

    btn.onclick = ()=>{
      if(q.answered) return; // Prevent re-answering
      q.answered = true;
      q.userAnswer = i;
      btn.dataset.answered = 'true'; // Mark as answered

      // Visually mark chosen option and correct answer
      Array.from(cont.children).forEach(optionBtn => {
        const optionIndex = parseInt(optionBtn.dataset.index);
        if (optionIndex === i) { // User's choice
          optionBtn.style.background = i === q.correct ? 'var(--light-green)' : 'var(--light-red)';
          optionBtn.style.border = i === q.correct ? `1px solid var(--green)` : `1px solid var(--red)`;
        } else if (optionIndex === q.correct) { // The actual correct answer
          optionBtn.style.background = 'var(--light-green)';
          optionBtn.style.border = `1px solid var(--green)`;
        } else { // Other options
          optionBtn.style.background = '#f8fcff';
          optionBtn.style.border = '1px solid var(--border-color)';
        }
      });

      el('explanation').innerText = (i === q.correct ? '✅ Correct. ' : '❌ Incorrect. Correct answer: ' + (q.options && q.options[q.correct] ? q.options[q.correct] : '')) + (q.explanation ? ' — ' + q.explanation : '');
      clearInterval(questionTimer); // Stop timer after answer
    };
    cont.appendChild(btn);
  });
  if (!q.answered) { // Only start timer if not already answered
      startQuestionTimer();
  } else {
      clearInterval(questionTimer); // Ensure timer is stopped if re-rendering an answered question
      el('countdown').innerText = 'Time: 0s'; // Show timer as finished
  }
}

function nextQuestion(){
  // If current question wasn't answered when moving next, mark as skipped
  if (!quizData[currentQuestionIndex].answered) {
    quizData[currentQuestionIndex].skipped = true;
    quizData[currentQuestionIndex].answered = true; // Mark as answered to prevent re-interaction
    quizData[currentQuestionIndex].userAnswer = null; // No answer
  }

  if(currentQuestionIndex < quizData.length -1){
    currentQuestionIndex++; renderQuestion();
  }
  else submitQuiz();
}

function prevQuestion(){
  if(currentQuestionIndex > 0){
    currentQuestionIndex--; renderQuestion();
  }
}

function skipQuestion(){
  if (!quizData[currentQuestionIndex].answered) { // Only mark as skipped if not already answered
    quizData[currentQuestionIndex].skipped = true;
    quizData[currentQuestionIndex].answered = true; // Mark as answered to prevent re-interaction
    quizData[currentQuestionIndex].userAnswer = null; // No answer
  }
  nextQuestion(); // Move to next question after skipping
}

function startQuestionTimer(){
  let timeLeft = 30; // 30 seconds per question
  el('countdown').innerText = `Time: ${timeLeft}s`;
  if(questionTimer) clearInterval(questionTimer);
  questionTimer = setInterval(()=> {
    timeLeft--;
    el('countdown').innerText = `Time: ${timeLeft}s`;
    if(timeLeft<=0){
      clearInterval(questionTimer);
      // auto-skip and move to next
      if (!quizData[currentQuestionIndex].answered) {
        quizData[currentQuestionIndex].skipped = true;
        quizData[currentQuestionIndex].answered = true;
        quizData[currentQuestionIndex].userAnswer = null;
      }
      if(currentQuestionIndex < quizData.length -1){ currentQuestionIndex++; renderQuestion(); }
      else submitQuiz(); // If last question, submit quiz
    }
  },1000);
}

function submitQuiz(){
  if(questionTimer) clearInterval(questionTimer);

  // Ensure the last question is marked as skipped if not answered
  if (!quizData[currentQuestionIndex].answered) {
    quizData[currentQuestionIndex].skipped = true;
    quizData[currentQuestionIndex].answered = true;
    quizData[currentQuestionIndex].userAnswer = null;
  }

  // Tally results
  let correct=0, wrong=0, skipped=0;
  quizData.forEach(q=>{
    if(q.answered && q.userAnswer !== null && q.userAnswer === q.correct) correct++;
    else if(q.answered && q.userAnswer !== null && q.userAnswer !== q.correct) wrong++;
    else if(q.skipped) skipped++;
  });

  el('res-total').innerText = quizData.length;
  el('res-correct').innerText = correct;
  el('res-wrong').innerText = wrong;
  el('res-skipped').innerText = skipped;

  // Show results area
  hide(el('quiz-area'));
  show(el('results-area'));
  el('save-result-btn').disabled = false;
  renderLocalHistory(); // Display updated local history
}

/* =========================
   Event wiring
   ========================= */
document.addEventListener('click', (e) => {
  if(e.target && e.target.id === 'join-button'){
    participantName = el('participant-name').value.trim();
    saveParticipantNameLocally(participantName); // Save name locally

    hide(el('results-area'));
    show(el('quiz-area'));
    if(quizData.length) { currentQuestionIndex=0; renderQuestion(); }
  }
});
el('prev-btn').onclick = prevQuestion;
el('next-btn').onclick = nextQuestion;
el('skip-btn').onclick = skipQuestion;
el('submit-btn').onclick = submitQuiz;
el('restart-btn').onclick = ()=>{
  location.reload(); // Simple reload to restart the quiz entirely
};
el('save-result-btn').onclick = async ()=>{
  const result = {
      name: participantName,
      date: new Date().toISOString(),
      total: quizData.length,
      correct: parseInt(el('res-correct').innerText),
      wrong: parseInt(el('res-wrong').innerText),
      skipped: parseInt(el('res-skipped').innerText)
  };
  saveQuizResultLocally(result);
  showMessage('Your quiz result has been saved locally!');
  el('save-result-btn').disabled = true; // Disable after saving
};
el('participant-name').value = getParticipantNameLocally(); // Load name on startup

/* =========================
   Main routine: load schedule, pick chapter, generate or load MCQs
   ========================= */
async function main(){
  // Load schedule first
  await loadSchedule();

  // Get accurate time (local device time)
  const now = await getAccurateTime();
  el('schedule-info').innerText = `Current local time: ${now.toLocaleString('en-NP', {dateStyle: 'full', timeStyle: 'medium'})}`;

  // Pick appropriate chapter based on current time
  currentChapter = pickCurrentChapter(now);
  if(!currentChapter){
    el('chapter-title').innerText = 'No chapter scheduled yet (or schedule missing/future).';
    el('join-button').disabled = true;
    return;
  }
  el('chapter-title').innerText = `Scheduled: ${currentChapter.chapter} (starts ${currentChapter.time.toLocaleString('en-NP', {dateStyle: 'medium', timeStyle: 'short'})})`;

  // Generate MCQs (Gemini) — this can take a few seconds
  try{
    quizData = await generateMCQs(currentChapter.chapter);
    // Ensure structure and add initial state for each question
    quizData = quizData.map(q => ({ ...q, answered:false, userAnswer:null, skipped:false }));
    el('join-button').innerText = 'Join Quiz';
    el('join-button').disabled = false;
  }catch(e){
    el('chapter-title').innerText = `Error generating questions: ${e.message || e}`;
    el('join-button').innerText = 'Retry';
    el('join-button').disabled = false;
    el('join-button').onclick = ()=> location.reload();
  }
  renderLocalHistory(); // Display existing local history on load
}

// Start the main application logic when the page loads
document.addEventListener('DOMContentLoaded', main);

/* =========================
   small helper: escape html
   ========================= */
function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
}
</script>
</body>
</html>
